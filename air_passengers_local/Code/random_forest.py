#!/usr/bin/env python3# -*- coding: utf-8 -*-"""Created on Sun Apr 26 15:27:47 2020@author: dorian"""import osimport importlibimport numpy as npimport pandas as pdimport matplotlib.pyplot as pltfrom sklearn.preprocessing import OrdinalEncoder, OneHotEncoderfrom sklearn.compose import make_column_transformerfrom sklearn.ensemble import RandomForestRegressorfrom sklearn.pipeline import make_pipelinefrom sklearn.model_selection import cross_val_scoreimport problemfrom sklearn.model_selection import RandomizedSearchCVfrom sklearn.preprocessing import FunctionTransformerdef _encode_dates(X):    # With pandas < 1.0, we wil get a SettingWithCopyWarning    # In our case, we will avoid this warning by triggering a copy    # More information can be found at:    # https://github.com/scikit-learn/scikit-learn/issues/16191    X_encoded = X.copy()    # Make sure that DateOfDeparture is of datetime format    X_encoded.loc[:, 'DateOfDeparture'] = pd.to_datetime(X_encoded['DateOfDeparture'])    # Encode the DateOfDeparture    X_encoded.loc[:, 'year'] = X_encoded['DateOfDeparture'].dt.year    X_encoded.loc[:, 'month'] = X_encoded['DateOfDeparture'].dt.month    X_encoded.loc[:, 'day'] = X_encoded['DateOfDeparture'].dt.day    X_encoded.loc[:, 'weekday'] = X_encoded['DateOfDeparture'].dt.weekday    X_encoded.loc[:, 'week'] = X_encoded['DateOfDeparture'].dt.week    X_encoded.loc[:, 'n_days'] = X_encoded['DateOfDeparture'].apply(        lambda date: (date - pd.to_datetime("1970-01-01")).days    )    # Once we did the encoding, we will not need DateOfDeparture    return X_encoded.drop(columns=["DateOfDeparture"])#Loading  training dataX, y = problem.get_train_data()#########################################################################################################################                                            #Random Forest with OneHotEncoder######################################################################################################################################################################Preprocessing training data#####################################date_encoder = FunctionTransformer(_encode_dates)date_cols = ["DateOfDeparture"]categorical_encoder = OneHotEncoder(handle_unknown="ignore")categorical_cols = [    "Arrival", "Departure", "year", "month", "day","weekday", "week", "n_days"    ]preprocessor = make_column_transformer(    (categorical_encoder, categorical_cols),)#############################################Find best parameters#############################################parameters = {'randomforestregressor__n_estimators': [int(x) for x in np.linspace(start = 200, stop = 2000, num = 10)],               'randomforestregressor__max_features': ['auto', 'sqrt'],               'randomforestregressor__max_depth': [int(x) for x in np.linspace(10, 110, num = 11)],               'randomforestregressor__min_samples_split': [int(x) for x in np.linspace(2, 20, num = 8)],               'randomforestregressor__min_samples_leaf': [int(x) for x in np.linspace(1, 20, num = 10)],               'randomforestregressor__bootstrap': [True, False]}pipeline_cv_2 = make_pipeline(date_encoder,preprocessor, RandomForestRegressor())cv_rf_2 = RandomizedSearchCV(pipeline_cv_2, parameters, cv=5, n_jobs=-1, n_iter = 100)cv_rf_2.fit(X, y)best_parameters_2 = cv_rf_2.best_params_"""#############################################Create pipeline with best parameters###############################Best parametersn_estimators =  1400min_samples_split =  2min_samples_leaf =  2max_features = 'auto'max_depth = 70bootstrap =  Trueregressor = RandomForestRegressor(    n_estimators=n_estimators, max_depth=max_depth, max_features=max_features, min_samples_split = min_samples_split, min_samples_leaf = min_samples_leaf, bootstrap = bootstrap, n_jobs = -1)pipeline_2 = make_pipeline(date_encoder,preprocessor, regressor)scores_2 = cross_val_score(    pipeline_2, X, y, cv=5, scoring='neg_mean_squared_error')rmse_scores_2 = np.sqrt(-scores_2)print(    f"RMSE: {np.mean(rmse_scores_2):.4f} +/- {np.std(rmse_scores_2):.4f}")"""